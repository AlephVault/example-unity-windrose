WindRose
========

1. Introducción

Este es como un motorcito que sirve para regular el movimiento de personajes en 2 dimensiones, onda Pokémon (los clásicos).
Esto nos sirve para regular el movimiento "en grilla" de personajes y cosas que pueden ser de 1x1 casillas, o 2x2, o cualquier dimensión, mientras que en juegos como Pokémon, solo se tiene el movimiento de objetos de 1x1 (sí, lo pensé para bancar más movimientos).

El hecho de que usemos este motorcito nos va a ahorrar darnos cuenta a mano de que tenemos un objeto de frente, o tener que regular el movimiento a mano para "encasillar" o alinear correctamente el movimiento de los personajes. Sin embargo, no por usar este motor nos vamos a privar necesariamente de interactuar con las colisiones regulares. Un ejemplo podría ser que haya una bola de fuego de tamaño y movimiento irregular (que no tenga nada que ver con este motor) y aún así pueda colisionar con el personaje principal, y este se muera.

2. Mapas y objetos

Todo esto se trata de que hay un "mapa" y varios objetos en él. Realmente no lo probé con más de un mapa, pero no creo que tenga problema alguno si usamos dos mapas distintos. Sin embargo, esos dos mapas no tienen forma de interactuar (o sea: restringirse movimiento entre los diferentes objetos) entre sí (a priori, toda posible interacción ocurre dentro de un solo mapa).

2.1. Mapas

El script de "mapa" se encuentra en la carpeta Assets/Scripts/WindRose/Behaviors/Map.cs. El GameObject al que se adjunta no necesitará ningún comportamiento preexistente, aunque será su par de coordenadas (x, y) lo que nos interese. En este caso, no es porque esas coordenadas influyan de alguna manera en cómo funciona el motor, sino porque la forma en que se calcula todo lo que es la generación del mapa nos importa.

A ver: El mapa "crece" hacia arriba y hacia a la derecha (en la pantalla), por eso en un ejemplo yo le puse las coordenadas (-8, -6), es decir, en coordenadas "abajo y a la izquierda", para que se centre en la pantalla (siendo las dimensiones lógicas de 16x12).

Las propiedades que nos interesan son:

width: Esta propiedad existe solamente en el editor (es privada en tiempo de ejecución).
       Este valor es un entero entre 1 y 100. Es el ancho lógico del mapa.
height: Similar. El alto. También entre 1 y 100.
blockMask: Es una textura. Esta propiedad existe solamente en el editor. En ella vamos a pintar como queramos "bloquear" las posiciones.
           Es decir: ningún objeto puede moverse hacia una posición "bloqueada".
           Al pintar la textura (ponele, con paint), los píxeles negros van a ser "libres", mientras que cualquier color que no sea RGB(0, 0, 0) va a ser bloqueado.
           En caso de no poner una máscara de bloqueo, la máscara va a ser vacía (sin bloqueos).
maskApplicationOffsetX y maskApplicationOffsetY: Indicaremos la posicion en X y en Y desde la cual vamos a aplicar la máscara en el mapa.
                                                 Estas coordenadas son lógicas (no tienen que ver con Unity, sino con este motor en particular).
                                                 Aún así, guardan cierta relación con las coordenadas de Unity (según que Scale tenga el GameObject del mapa).
                                                 Las coordenadas (X2, Y2) tal que X2 < X o Y2 < Y, van a estar libres.
                                                 La coordenada (X, Y) va a estar bloqueada o no, en función del pixel (0, 0) dependiendo de si es negro o no.

Las propiedades públicas que nos interesan son:

Width, Height: Ancho y alto del mapa, según inicializados en el editor.

Los métodos de los que disponemos son:

Pause(false): Congela todos los movimientos de los objetos en el mapa. Sin embargo, las animaciones siguen corriendo.
Pause(true): Congela todos los movimientos de los objetos en el mapa. Las animaciones TAMBIÉN se congelan.
Resume(): Reanuda todos los movimientos (y animaciones) de los objetos en el mapa.

2.2 Cargadores de Mapas

Lo normal es que no vamos a armar un mapa a mano. Esto es por varios motivos:

I. Tendríamos que armar la imagen de alguna manera, y en cosas como dispositivos móviles una imagen puede pesar mucho. Si llegamos a tener varios niveles, y tenemos una imagen de fondo para cada uno de esos niveles, puede crecer bastante. Y tal vez es un arreglo feo tileado de una imagen repetida, que rompe las bolas.
II. Especificar la máscara de bloqueo, y mantener al día tanto la imagen de fondo (que sí o sí necesitaríamos! un paisaje, una montaña, un bosque...) puede rompernos más las bolas. Ideal sería tener todo en una sola lógica.
III. Podríamos pensar cada mapa/nivel de manera "modular" si tuviéramos una lógica mejor y "en capas".

Con los cargadores de mapas vamos a poder solucionar este problema!

El script de "cargador de mapa" se encuentra en la carpeta Assets/Scripts/WindRose/Behaviors/MapLoader.cs

Para agregar uno, necesitamos solamente un GameObject. EL MISMO NO DEBE TENER UN COMPORTAMIENTO WindRose.Behaviors.Map DE ANTEMANO. Eso es un error.
La onda con esto, es que el propio GameObject que ahora tiene el MapLoader, va a tener (apenas el nivel arranque) un objeto Map (el que ya explicamos) en sí mismo.

En Tiempo de Ejecución, el MapLoader no tiene más utilidad. TODA SU EJECUCIÓN OCURRE EN Start().
Las propiedades que nos importan son todas en el EDITOR. Toda la generación del mapa se hace "en capas".

El ancho y el alto, son exactas propiedades de como ocurre
El arreglo de capas es en orden. La primera capa (el índice 0) será la de más atrás.
También habrá una tasa de relación entre unidades y píxeles. Normalmente los sprites tienen una de estas, pero ahora vamos a estar generando las texturas dinámicamente, por lo que tenemos que trabajar este valor nosotros. Por default este valor es de 32 y no lo vamos a cambiar. Esto es xq las texturas que tomaremos como fuente para generar los mapas (que están en este mismo proyecto) contienen elementos que son de 32x32. No es obligatorio que diferentes mapas tengan el mismo valor en esta propiedad, pero puede llegar a ser recomendado si mostramos varios en el mismo nivel y tenemos que meter algo de mano para usar esos mapas juntos.

Las capas cumplen 2 funciones:

I. Ir generando la imagen que va de fondo.
II. Ir generando la máscara de bloqueo del mapa.

Las capas son las más putas de todas. Tenemos ahí un montón de propiedades que nos van a interesar! Ante todo, una capa tiene una propiedad "Layer Type" que nos dice el tipo de capa que tenemos. Son los siguientes:

I. Relleno

Nos permite especificar una textura (y un rectángulo que tomar de esa textura! siendo lo ideal que en píxeles esa textura termine siendo de TxT pero no es obligado, donde T es la tasa esa de unidades). También nos permite especificar si esa textura "bloqueará" o "liberará" toda la máscara de bloqueo.

Cada casilla tendrá esa textura (ese tile) y esa especificación de bloqueo.

Esta capa está pensada para ser la PRIMERA si es que la vamos a usar. No tenemos restricción de que sea la segunda, tercera, ... pero ponerla en una posición que no sea PRIMERA lo que va a hacer es que las capas anteriores estén al pedo.

Tiene una especificación de Random Source y Options que vamos a explicar después.

II. Bioma

Esta es la más puta de explicar! La de bioma nos permite especificar una textura de fuente que puede ser, ponele, nieve desierto agua pasto ...
Y nos sirve para dar un patrón correctamente bordeado (es decir: esquinas bordeadas) de acuerdo a los límites que especifiquemos.

Un caso de estudio de esta capa, es el siguiente:

Paso 1. Una capa de relleno (la que explique anteriormente) que sea de pura arena (no-bloqueante).
Paso 2. Una capa de bioma que contenga un pequeño oasis (siendo sus posiciones bloqueantes, para que un pj no pueda caminar sobre el agua).

Para esto, la capa de bioma tiene 2 elementos fundamentales:

I. Textura con especificación de presencia del bioma.
II. Textura fuente con las 16 regiones que indican todas las posibles esquinas del bioma.

La textura II sirve como paleta, mientras que la textura I sirve como especificación de cómo pintar.

A ver: La textura I (presencia del bioma) debe medir W+1 x H+1, donde W y H son las dimensiones del mapa.
Adicionalmente, la textura será desplazada según BiomeOffsetX y BiomeOffsetY (esas propiedades se ven ahi mismo en el editor).
No te preocupes! Si por alguna razón la textura te queda más grande o más chica, se va a truncar o "rellenar con 0" apropiadamente.

La razón de que la textura de presencia mida 1 más en cada coordenada, es porque para decidir qué mostrar en el tile (X, Y), se toman 4 valores de la textura de presencia: (X, Y) (X+1, Y) (X, Y+1) (X+1, Y+1). estos son las 4 *esquinas* del tile final. Digamos que si el color es negro, esa esquina vale 0, y sino, esa esquina vale 1. Entonces vamos a seleccionar la región correcta de la textura fuente (II). Por ejemplo, si las 4 esquinitas (0, 0) a (1, 1) fueran:

00
01

Entonces el tile que verías en la posicion (0, 0) sería una esquinita superior izquierda convexa.

Otras propiedades que nos interesan son:

Biome Blocking Mode: Nos indica si los tiles que pintemos van a bloquear el paso, o van a desbloquear el paso (si los anteriores bloqueaban - por ejemplo si el bioma es una pequeña isla en medio de un mar de relleno, donde el mar es una capa de relleno bloqueante). Podemos decirle que es bloqueante, que es liberador, o que no afecta lo que estaba ya puesto. Sabemos lo siguiente de antemano:

I. Un tile generado por las 4 esquinas en 0, será transparente, no bloqueará ni desbloqueará lo que venga de antes.
II. Un tile generado con las 4 esquinas en 1, será central. Bloqueará si el modo de bloqueo que elegimos en la propiedad anterior es bloqueante. Desbloqueará si el modo es desbloqueante. Y será indiferente si el modo que elegimos es indiferente.

La siguiente propiedad es Biome Extended Presence. Esta nos indica si las otras combinaciones de esquinitas tendrán un comportamiento de bloquear/liberar como las que son 1-1-1-1 (true, checkeada) o si se comportarán como las que son 0-0-0-0 (false, no checkeada).

Este tipo de capa también tiene una especificación de random como la anterior. Esto lo voy a explicar en un rato.

III. Personalizada

Esta capa es más sencilla. La onda es que tome un BMP con pixeles de colores, pero el significado de cada pixel es el que nosotros le demos:

I. Pixeles para los que no tengamos nada puesto, no harán nada.
II. Pixeles para los que sí tengamos algo puesto (tendremos por ahí una "paleta") harán algo.

Cómo funciona una paleta. Básicamente cada elemento de la paleta tiene algunas propiedades:

I. El color dentro de la textura ante el cual responder.
II. Una textura que tomar de fuente.
III. Una región de esa textura, tal que el cuadradito resultante sea de TxT.
IV. Una especificación que nos diga si ese pixel bloquea, libera, o no afecta la máscara final de bloqueo.

Apendice I. Elementos Random

La capa de relleno y la capa biomática pueden especificar elementos aleatorios a mostrar durante la generación de la textura.
En el caso de la capa biomática, estos elementos aleatorios solo pueden darse en casillas con esquinitas 1-1-1-1.

Funcionan de la siguiente manera:

I. Tenemos que especificar una textura fuente para el random, o será ignorado.
II. Tenemos diferentes elementos que pueden aparecer aleatoriamente. Estos constarán de:
II.I Una región de dicha textura fuente, siendo lo ideal que resulte en un cuadrado de MxM.
II.II Una probabilidad de aparecer. Es un valor entre 1 y 50.

Existe una restricción, si mal no recuerdo, y es que todas las probabilidades sumadas dentro de una misma especificacion de random no pueden sobrepasar el valor 50.

... Toda esta especificación va a ser leída por el método Start() del MapLoader, y vamos a tener nuestro mapa corriendo.

En el ejemplo se ve clarito.