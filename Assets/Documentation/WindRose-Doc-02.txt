WindRose
========

3. Comportamientos de objetos.

A ver: Si tenemos un mapa, también vamos a tener objetos dentro de ese mapa. Estos objetos tienen algunas caracteristicas que son diferentes de cualquier otro objeto en unity. Por ejemplo, nos va a importar mucho que el sistema de colisiones que usemos no sea el natural de Unity, solamente por el tipo de juego que estamos construyendo con esto. En vez de eso, tenemos nuestro propio sistema de colisión que en realidad está basado en las casillas de cada mapa. Esto quiere decir que a estos fines no se gatillan los eventos de colisión de Unity cuando un personaje no te deja pasar un camino.

Esto no quiere decir que no podamos usar otras funcionalidades de unity! Por ejemplo, tranquilamente podemos hacer que si nuestro personaje es impactado por una bola de fuego que viene desde algún lado, su comportamiento de colisión se active y reaccione (probablemente muriendo) ante la bola de fuego. Esto es porque la bola de fuego no necesita ser un objeto que siga las reglas que definimos para este tipo de mapas (es decir: las colisiones celda por celda). Ni siquiera estaríamos exigiendole que siga un camino ortogonal! Eso dependerá de nuestro juego. Y esto es porque WindRose solo está hecho para limitar la movilidad y maniobrabilidad de los objetos que ocupen lugar en el mapa y tengan movimiento con intención de ocupar lugar.

Pero entonces, si tenemos que para muchas cosas podemos usar funcionalidad normal de Unity ¿Qué capacidades nos ofrecen estos objetos?

Bueno, tenemos algunas (WindRose.Behaviors):

3.1 Positionable

Nos permite darle posición y dimensión al objeto en el mapa. Es el más importante de todos xq sirve para todos los objetos.
La posición es un par de valores X, Y en el editor, que van de 0, 0 hasta W-1, H-1 siendo W, H el ancho y alto del mapa.

Esto nos permite indicar cómo es realmente el objeto que vamos a poner en el mapa. Siempre hablamos de un objeto rectangular.

ESTE COMPORTAMIENTO NO ACTUALIZA LA POSICION DEL gameObject SUBYACENTE. EL COMPORTAMIENTO QUE LO HACE ES 3.3 Snapped MAS ABAJO.

El otro factor es el de SOLIDEZ. Existen 3 tipos de solidez:

 I. Fantasma: Nada le impide el paso. De la misma manera, este objeto no le impide el paso a nada. O sea: no colisiona ni recibe colisiones.
 II. Solido: Este objeto es sólido y colisionará con otros objetos (excepto Fantasma, obvio). De la misma forma, bloqueará el paso a otros objetos sólidos.
 III. Solido para otros: Este objeto se puede mover libremente como fantasma, pero recibirá colisión (es decir: bloqueará el paso) de cualquier objeto sólido.

Finalmente la propiedad Movement: Nos indica que se está realizando un movimiento en alguna dirección.
  MAS INFORMACIÓN DE ESTO EN 3.5 Movable.

Todo esto se relaciona con un mapa al que no tenemos acceso directo (solamente podemos alterarlo mediante los Positionables involucrados).

En este sentido, tenemos algunas funcionalidades creadas para este fin:

 I. positionable.Teleport(x, y): Nos permite teletransportar el objeto a cierta posición en el mapa.
    Si había algún movimiento inconcluso (lo veremos más adelante) el movimiento es cancelado.
 II. positionable.SetSolidness(s): Nos permite cambiar la solidez del objeto.
     No lo hice como propiedad, para conservar el estilo de estos métodos.
 III. positionable.Pause(_): Pausa el positionable, impidiendo que se pueda invocar cualquier otro método que no sea Pause o Resume.
 IV. positionable.Resume(): Restaura el positionable, quitando lo que hace Pause.
 V. StartMovement(dirección): Nos permite iniciar un movimiento en cierta dirección.
    El movimiento quedará inconcluso hasta que llamemos a CancelMovement para cancelarlo, o a FinishMovement para confirmarlo.
    Esto nos permite mantener actualizadas la ocupación de las casillas involucradas para que los otros objetos colisionen correctamente sin superponerse.
 VI. CancelMovement(): Cancela el movimiento iniciado por StartMovement, restaurando la colisión anterior.
 VII. FinishMovement(): Confirma dicho movimiento, quedandonos solamente con las nuevas casillas ocupadas para colisionar, y liberando las anteriores, que ocupara el objeto.

3.2 Represented (depende de Snapped, aunque la verdad al pedo pero we)

Nos permite darle una animación al objeto. Esta animación no es como el objeto AnimationClip de unity sino algo a mano que responde más a nuestras necesidades.
La necesidad de usar estas animaciones radica en que de alguna manera podríamos necesitar componer la animación con texturas nosotros mismos (ejemplo: combinando ropas).

Entonces, cambiar la animación nos ayuda para cambiar la apariencia del PJ o incluso la animación a mostrar cuando se cambia de dirección al moverse para otro lado.

En el editor vamos a encontrar la propiedad DefaultAnimation, para especificar los frames de la animación que usará primero.
Es nuestro deber, en TODAS las animaciones, que nos aseguremos que el punto pivote sea apropiado. De esto nos tenemos que asegurar en el editor, por cada textura que importemos como Sprite, o al momento de crear un nuevo objeto Sprite en tiempo de ejecución.

Nos ofrece las siguientes funcionalidades:

 I. SetDefaultAnimation(): Devuelve al objeto la animación inicial (Aquella con la que fue creado originalmente.
 II. Pause(true): Congela la animación. El objeto se verá congelado en la pantalla. Los frames no se moverán.
 III. Pause(false): No hace nada.
 IV. Resume(): Reanuda la animación (si fue congelada previamente; sino, no hace nada).

3.3 Snapped (depende de Positionable)

Para nuestra suerte, este comportamiento hace todo por sí solo dependiendo de Positionable, y nosotros no tenemos que meter mano en nada.
En este sentido, actualiza la posición que especifica el objeto Positionable, y permite los movimientos en las direcciones que se pueda dar al Positionable.

3.4 Oriented (depende de Represented)

Este nos permite especificar no una animación sino un conjunto de animaciones. Este conjunto de animaciones tiene que ver con que para cada dirección posible tendremos una animación distinta. Entonces tendremos un conjunto básico de 4 animaciones predeterminado, y será seleccionada la animación dada por la dirección que se espefica en su propiedad `orientation`, que puede o no coincidir con el movimiento que se esté realizando en un positionable.

En el editor vamos a encontrar dos propiedades:

  Orientation: La orientación inicial del objeto.
    En tiempo de ejecución podremos cambiar esta propiedad.
  Idle Animation Set: El conjunto predeterminado de animaciones.
    Lo normal es que un objeto orientable que no tenga otras animaciones, va a usar esta animación.
    Al reorientar el objeto usando la propiedad Orientation, se va a cambiar de animación tomando algun miembro dentro de este conjunto.

Internamente, en tiempo de ejecución, la onda es distinta.

Vamos a tener la capacidad de instalar y manejar VARIOS de estos conjuntos de animaciones. La funcionalidad que vamos a manejar es la siguiente:

  I. orientable.animationKey: un string indicando el conjunto de animaciones a utilizar, de los instalados.
       Por default disponemos del valor vacío (""). Si el key que estamos asignando no existe, será reemplazado por "".
  II. orientable.overriddenKeyForIdleAnimation: un string indicando el key que vamos a usar como animación predeterminada.
        Nos sirve en el caso de que queramos tener una animación "idle" diferente a la que tenemos de manera predeterminada, por un momento.
  III. orientable.SetIdleAnimation(): hace que el objeto orientable utilice el conjunto predeterminado de animaciones.
         Este conjunto será el que especificamos al inicio (cuyo key es "") o, si existe, el que tengamos bajo el key en
         overriddenKeyForIdleAnimation (es acá donde se usa esa propiedad).
  IV. orientable.AddAnimationSet(strKey, AnimationSet set): Instala un nuevo conjunto de animaciones, bajo un nuevo key.
        La onda con esto es que lo usemos no arbitrariamente, sino como parte de otro comportamiento (por ejemplo, el comportamiento Movable
        va a hacer precisamente esto: agregar un key nuevo, con un conjunto nuevo de animaciones).

  LA CAGUÉ, y tengo que meterle la funcionalidad esta: Permitir reemplazar el contenido de las animaciones.
    No sé en qué momento se me saltó eso pero necesitaríamos uno onda ReplaceAnimationSet o algo así.

  V. orientable.Pause(_): Congela este comportamiento, de tal manera que no se verá cambiar ni el conjunto de animación actual ni la orientación.
  VI. orientable.Resume(): Descongela este comportamiento, para que funcione normalmente.

3.5 Movable (depende de Orientable)

Este es prácticamente el meollo de este motor. Permite mover a los objetos que lo tengan.

Primero que nada, en el editor tendremos un nuevo conjunto de animaciones que es para el objeto en movimiento.
Tal como lo explicamos en Orientable, utiliza un nuevo key para instalar esa animación: "move".

ESTE COMPORTAMIENTO SE ENCARGA DE MOVER AL OBJETO, de desplazarlo en términos de unidades, en el juego visible.
Se marca el movimiento actual cuando se comienza. El movimiento permanece hasta que se cancele explícitamente, o hasta que alcance la próxima casilla (ahí se detendrá y renovará si es el caso).

Nos interesan algunas propiedades en tiempo de ejecución como:

  I. movable.IsMoving: Indica si el objeto se está moviendo. En realidad esto toma el valor de positionable.Movement.
  II. movable.speed: La velocidad (en unidades/segundo) de movimiento.
  III. movable.overriddenKeyForMovingAnimation: El key que usaremos, en vez de "move", temporalmente para usar otra animación para el movimiento.
  IV. movable.SetMovingAnimation(): Hace que el objeto orientable utilice el conjunto de animaciones para movimiento.
        Este conjunto será el que especifiquemos al inicio (cuyo key es "move") o, si existe, el que tengamos bajo el key en
        overriddenKeyForMovingAnimation (es acá donde se usa esa propiedad).
  V. movable.Pause(_): Congela este comportamiento. El movimiento del objeto se congela, haya terminado o no.
       Al despausar, el movimiento continúa (si tal es el caso).
  VI. movable.Resume(): Reanuda todo posible movimiento.

3.6 AttentionCenter

Este comportamiento lo único que hace es fijar una cámara (generalmente solo tendremos una cámara en el mapa, pero podría no ser el caso) a que siga al objeto.
Esto no depende ni de positionable ni nada, porque podríamos dárselo a cualquier objeto.
Este comportamiento no puede pausarse con llamadas a Pause/Resume porque esa API no es relevante para esto.
  De necesitarlo, Unity nos provee de la propiedad `enabled`, para desactivarlo (algunos de los comportamientos anteriores se basan en dicha propiedad, para implementar Pause/Resume).

4. Pausar y Reanudar

Los comportamientos descritos tienen, en general, una funcion de Pause/Resume. Esos comportamientos no invocan nunca esas funciones directamente, sino que esas funciones son receptores de mensaje de pausar/reanudar que vienen desde MAS arriba. Puntualmente vienen desde EL MAPA. Eso ya está explicado en la primera parte de la documentación.

5. Comportamientos adicionales

Hay algunos comportamientos que NO metí en WindRose y que probablemente podamos meter en algún momento, pero por ahora no quise porque los pensé más para probar como ejemplos.

5.1 KeyboardHandled (depende de Movable)

Nos permite manejar al personaje mediante el diamante direccional. Lo usa el personaje Diablo en el demo.

5.2 WaypointHandled (depende de Movable)

Nos permite especificar una secuencia puntual de movimientos para el personaje. Lo usa el personaje Luc en el demo.

Los movimientos se especifican en un array de elementos. Cada elemento especifica: la dirección, si es movimiento o solamente mirada, y el tiempo que demora entre completar el movimiento anterior y comenzar este.

5.3 Pausable

Se lo ponemos a un gameObject que tenga un componente Map o un componente MapLoader (finalmente, tendrá entonces un Map).

Al presionar Q, se invocará Pause(true) sobre el mapa.
Al presionar W, se invocará Pause(false) sobre el mapa.
Al presionar E, se invocará Resume() sobre el mapa.

Es importante recordar que las 3 llamadas sobre un mapa, lo que hacen es invocar las 3 respectivas llamadas sobre cada uno de los objetos en el mapa, y por lo tanto sobre cada uno de los comportamientos (todos ellos responden a Pause(bool) y Resume()).