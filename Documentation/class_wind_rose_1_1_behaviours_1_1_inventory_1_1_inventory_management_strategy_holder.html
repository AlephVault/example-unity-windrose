<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WindRose: WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">WindRose
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">An orthogonal RPG game making framework for Unity</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_wind_rose.html">WindRose</a></li><li class="navelem"><a class="el" href="namespace_wind_rose_1_1_behaviours.html">Behaviours</a></li><li class="navelem"><a class="el" href="namespace_wind_rose_1_1_behaviours_1_1_inventory.html">Inventory</a></li><li class="navelem"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html">InventoryManagementStrategyHolder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p> 
 <a href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder_1_1_invalid_strategy_component_exception.html">InvalidStrategyComponentException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells when an invalid strategy is chosen as the value of mainUsageStrategy, or that property is null.  <a href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder_1_1_invalid_strategy_component_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder_1_1_stack_rejected_exception.html">StackRejectedException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells when a stack is rejected in the inventory due to having invalid quantity value, not having the required spatial strategy, or having an incompatible usage strategy.  <a href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder_1_1_stack_rejected_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae0b12e5cd15c7ea2095a64dc1abfce99"><td class="memItemLeft" align="right" valign="top">IEnumerable&lt; <a class="el" href="class_support_1_1_types_1_1_tuple.html">Tuple</a>&lt; object, <a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#ae0b12e5cd15c7ea2095a64dc1abfce99">StackPairs</a> (object containerPosition, bool reverse=false)</td></tr>
<tr class="memdesc:ae0b12e5cd15c7ea2095a64dc1abfce99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a particular container ID, this method returns an iterable traversing all the stacks in such container.  <a href="#ae0b12e5cd15c7ea2095a64dc1abfce99">More...</a><br /></td></tr>
<tr class="separator:ae0b12e5cd15c7ea2095a64dc1abfce99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ee625958955530ac6ad437c7b75c58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#a43ee625958955530ac6ad437c7b75c58">Find</a> (object containerPosition, object stackPosition)</td></tr>
<tr class="memdesc:a43ee625958955530ac6ad437c7b75c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a stack located in a particular container and a particular position.  <a href="#a43ee625958955530ac6ad437c7b75c58">More...</a><br /></td></tr>
<tr class="separator:a43ee625958955530ac6ad437c7b75c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b04dc1649293e405585651710941b3"><td class="memItemLeft" align="right" valign="top">IEnumerable&lt; <a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#a57b04dc1649293e405585651710941b3">FindAll</a> (object containerPosition, Func&lt; <a class="el" href="class_support_1_1_types_1_1_tuple.html">Tuple</a>&lt; object, <a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a> &gt;, bool &gt; predicate, bool reverse=false)</td></tr>
<tr class="memdesc:a57b04dc1649293e405585651710941b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all the stacks in a particular container that satisfy a condition.  <a href="#a57b04dc1649293e405585651710941b3">More...</a><br /></td></tr>
<tr class="separator:a57b04dc1649293e405585651710941b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f494a3148710ad6039b3c9a2b715d5"><td class="memItemLeft" align="right" valign="top">IEnumerable&lt; <a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#a06f494a3148710ad6039b3c9a2b715d5">FindAll</a> (object containerPosition, <a class="el" href="class_wind_rose_1_1_scriptable_objects_1_1_inventory_1_1_items_1_1_item.html">ScriptableObjects.Inventory.Items.Item</a> item, bool reverse=false)</td></tr>
<tr class="memdesc:a06f494a3148710ad6039b3c9a2b715d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all the stacks in a particular container of a particular item.  <a href="#a06f494a3148710ad6039b3c9a2b715d5">More...</a><br /></td></tr>
<tr class="separator:a06f494a3148710ad6039b3c9a2b715d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752de5bfacc33b5d99b6acffe3675e92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#a752de5bfacc33b5d99b6acffe3675e92">First</a> (object containerPosition)</td></tr>
<tr class="memdesc:a752de5bfacc33b5d99b6acffe3675e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first item inside the given container.  <a href="#a752de5bfacc33b5d99b6acffe3675e92">More...</a><br /></td></tr>
<tr class="separator:a752de5bfacc33b5d99b6acffe3675e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e23171c45af7eab487e9314240627e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#a81e23171c45af7eab487e9314240627e">Last</a> (object containerPosition)</td></tr>
<tr class="memdesc:a81e23171c45af7eab487e9314240627e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last item inside the given container.  <a href="#a81e23171c45af7eab487e9314240627e">More...</a><br /></td></tr>
<tr class="separator:a81e23171c45af7eab487e9314240627e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7711676e9d84138f0967ea5550e8d02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#af7711676e9d84138f0967ea5550e8d02">FindOne</a> (object containerPosition, Func&lt; <a class="el" href="class_support_1_1_types_1_1_tuple.html">Tuple</a>&lt; object, <a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a> &gt;, bool &gt; predicate, bool reverse=false)</td></tr>
<tr class="memdesc:af7711676e9d84138f0967ea5550e8d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#a57b04dc1649293e405585651710941b3" title="Finds all the stacks in a particular container that satisfy a condition.">FindAll(object, Func&lt;Tuple&lt;object, Stack&gt;, bool&gt;, bool)</a> but only returns the first matched stack, or null.  <a href="#af7711676e9d84138f0967ea5550e8d02">More...</a><br /></td></tr>
<tr class="separator:af7711676e9d84138f0967ea5550e8d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacb29c3a7dd9bc7024eb622b9560a4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#afacb29c3a7dd9bc7024eb622b9560a4c">FindOne</a> (object containerPosition, <a class="el" href="class_wind_rose_1_1_scriptable_objects_1_1_inventory_1_1_items_1_1_item.html">ScriptableObjects.Inventory.Items.Item</a> item, bool reverse=false)</td></tr>
<tr class="memdesc:afacb29c3a7dd9bc7024eb622b9560a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like FindAll(object, ScriptableObjects.Inventory.Items.Item, bool) but only returns the first matched stack, or null.  <a href="#afacb29c3a7dd9bc7024eb622b9560a4c">More...</a><br /></td></tr>
<tr class="separator:afacb29c3a7dd9bc7024eb622b9560a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe389b82c60b4a722ea9e5fed42aca47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#afe389b82c60b4a722ea9e5fed42aca47">Put</a> (object containerPosition, object stackPosition, <a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a> stack, out object finalStackPosition, bool? optimalPutOnNullPosition=null)</td></tr>
<tr class="memdesc:afe389b82c60b4a722ea9e5fed42aca47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts a stack (that must not belong to any inventory) in a specified container.  <a href="#afe389b82c60b4a722ea9e5fed42aca47">More...</a><br /></td></tr>
<tr class="separator:afe389b82c60b4a722ea9e5fed42aca47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14a78f409521eccbe4688d6f73c0d00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#aa14a78f409521eccbe4688d6f73c0d00">Remove</a> (object containerPosition, object stackPosition)</td></tr>
<tr class="memdesc:aa14a78f409521eccbe4688d6f73c0d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the stack at certain position inside a container.  <a href="#aa14a78f409521eccbe4688d6f73c0d00">More...</a><br /></td></tr>
<tr class="separator:aa14a78f409521eccbe4688d6f73c0d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a86d05299db20c6a0a2c507e7a03b7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#a7a86d05299db20c6a0a2c507e7a03b7a">Merge</a> (object containerPosition, object destinationStackPosition, object sourceStackPosition)</td></tr>
<tr class="memdesc:a7a86d05299db20c6a0a2c507e7a03b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two stacks in the same containers, provided both stacks are "mergeable" between them. The source stack will be merged into the destination stack, and both stacks will be merged creating a new stack with added quantities and interpolated properties. For this to work, stacks must have usage strategies that CAN be interpolated.  <a href="#a7a86d05299db20c6a0a2c507e7a03b7a">More...</a><br /></td></tr>
<tr class="separator:a7a86d05299db20c6a0a2c507e7a03b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce6916ddf53fe5297846e974c70578c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#adce6916ddf53fe5297846e974c70578c">Merge</a> (object destinationContainerPosition, object destinationStackPosition, <a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html">InventoryManagementStrategyHolder</a> sourceHolder, object sourceContainerPosition, object sourceStackPosition)</td></tr>
<tr class="memdesc:adce6916ddf53fe5297846e974c70578c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#a7a86d05299db20c6a0a2c507e7a03b7a" title="Merges two stacks in the same containers, provided both stacks are &quot;mergeable&quot; between them....">Merge(object, object, object)</a>. This is an alternate version (actually: this is the generic one) which can merge across different inventories. The logic will remain the same.  <a href="#adce6916ddf53fe5297846e974c70578c">More...</a><br /></td></tr>
<tr class="separator:adce6916ddf53fe5297846e974c70578c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05af5c5341f280be26eb5805edbcb92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#ab05af5c5341f280be26eb5805edbcb92">Take</a> (object containerPosition, object stackPosition, object quantity, bool disallowEmpty)</td></tr>
<tr class="memdesc:ab05af5c5341f280be26eb5805edbcb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes part of the specified stack. Just a quantity, and not necessarily the whole stack. If this method fails, it returns null (failure may occur by having a bigger quantity than what may be taken, or by the element not existing).  <a href="#ab05af5c5341f280be26eb5805edbcb92">More...</a><br /></td></tr>
<tr class="separator:ab05af5c5341f280be26eb5805edbcb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4299112205847709bb888e012210d00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#af4299112205847709bb888e012210d00">Split</a> (object sourceContainerPosition, object sourceStackPosition, object quantity, object newStackContainerPosition, object newStackPosition, out object finalNewStackPosition)</td></tr>
<tr class="memdesc:af4299112205847709bb888e012210d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a stack in two, by taking a particular quantity of the source stack and creating a new one.  <a href="#af4299112205847709bb888e012210d00">More...</a><br /></td></tr>
<tr class="separator:af4299112205847709bb888e012210d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ba41aaa0bf5841424585f516d31d1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#a10ba41aaa0bf5841424585f516d31d1a">Use</a> (object containerPosition, object stackPosition)</td></tr>
<tr class="memdesc:a10ba41aaa0bf5841424585f516d31d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">USES a stack in certain container and position. Using the item is an interaction between the usage strategy in the item/stack, and the usage strategy in the inventory (which is the one that has logic). The argument given to the use callback will be <code>null</code>.  <a href="#a10ba41aaa0bf5841424585f516d31d1a">More...</a><br /></td></tr>
<tr class="separator:a10ba41aaa0bf5841424585f516d31d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac059f9b93b2f6584ecd641e7aae940b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#ac059f9b93b2f6584ecd641e7aae940b6">Use</a> (object containerPosition, object sourceStackPosition, object argument)</td></tr>
<tr class="memdesc:ac059f9b93b2f6584ecd641e7aae940b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">USES a stack in certain container and position. Using the item is an interaction between the usage strategy in the item/stack, and the usage strategy in the inventory (which is the one that has logic). The argument given to the use callback will be also given.  <a href="#ac059f9b93b2f6584ecd641e7aae940b6">More...</a><br /></td></tr>
<tr class="separator:ac059f9b93b2f6584ecd641e7aae940b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce42e8fdd21b7226d4c81a0d70e55be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#a8ce42e8fdd21b7226d4c81a0d70e55be">Clear</a> ()</td></tr>
<tr class="memdesc:a8ce42e8fdd21b7226d4c81a0d70e55be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears ALL THE INVENTORY. Deleting all the stacks from all the inventories.  <a href="#a8ce42e8fdd21b7226d4c81a0d70e55be">More...</a><br /></td></tr>
<tr class="separator:a8ce42e8fdd21b7226d4c81a0d70e55be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b93453f6ce8a501170ff1eb5f7ad9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#ad0b93453f6ce8a501170ff1eb5f7ad9f">Blink</a> (object containerPosition, object stackPosition)</td></tr>
<tr class="memdesc:ad0b93453f6ce8a501170ff1eb5f7ad9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refreshes a stack in the rendering.  <a href="#ad0b93453f6ce8a501170ff1eb5f7ad9f">More...</a><br /></td></tr>
<tr class="separator:ad0b93453f6ce8a501170ff1eb5f7ad9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12ff63f1ecdaadc41b63b7153e674a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#ac12ff63f1ecdaadc41b63b7153e674a1">Blink</a> (object containerPosition)</td></tr>
<tr class="memdesc:ac12ff63f1ecdaadc41b63b7153e674a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refreshes all the stacks of a container in the rendering.  <a href="#ac12ff63f1ecdaadc41b63b7153e674a1">More...</a><br /></td></tr>
<tr class="separator:ac12ff63f1ecdaadc41b63b7153e674a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844f1af60d72434237749cbe3e95b90b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#a844f1af60d72434237749cbe3e95b90b">Blink</a> ()</td></tr>
<tr class="memdesc:a844f1af60d72434237749cbe3e95b90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refreshes all the stacks -in the inventory- in the rendering.  <a href="#a844f1af60d72434237749cbe3e95b90b">More...</a><br /></td></tr>
<tr class="separator:a844f1af60d72434237749cbe3e95b90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5533bc1fb8576a40db91846df0d88974"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#a5533bc1fb8576a40db91846df0d88974">Import</a> (<a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_serialized_inventory.html">Types.Inventory.SerializedInventory</a> serializedInventory)</td></tr>
<tr class="memdesc:a5533bc1fb8576a40db91846df0d88974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imports some serialized data and replaces the current content of the inventory manager with the parsed content from the serialized data.  <a href="#a5533bc1fb8576a40db91846df0d88974">More...</a><br /></td></tr>
<tr class="separator:a5533bc1fb8576a40db91846df0d88974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b09004328dd51890cd5d398c9c096c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_serialized_inventory.html">Types.Inventory.SerializedInventory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#af6b09004328dd51890cd5d398c9c096c">Export</a> ()</td></tr>
<tr class="memdesc:af6b09004328dd51890cd5d398c9c096c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counterpart of Import(Types.Inventory.SerializedInventory), this method serializes the content of the inventory.  <a href="#af6b09004328dd51890cd5d398c9c096c">More...</a><br /></td></tr>
<tr class="separator:af6b09004328dd51890cd5d398c9c096c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="namespace_wind_rose_1_1_behaviours_1_1_inventory.html">Inventory</a> management strategy holders are the live counterpart of the <a class="el" href="class_wind_rose_1_1_scriptable_objects_1_1_inventory_1_1_items_1_1_item.html">ScriptableObjects.Inventory.Items.Item</a> and their instantiated Stack objects, since the management strategy holders perform the actual logic of each aspect. </p>
<p>In the same game object, instances of the other strategy types must be added (usage, spatial, container positioning, and rendering). </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad0b93453f6ce8a501170ff1eb5f7ad9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b93453f6ce8a501170ff1eb5f7ad9f">&#9670;&nbsp;</a></span>Blink() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.Blink </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>containerPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>stackPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refreshes a stack in the rendering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">containerPosition</td><td>The ID of the container</td></tr>
    <tr><td class="paramname">stackPosition</td><td>The position of the stack</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac12ff63f1ecdaadc41b63b7153e674a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12ff63f1ecdaadc41b63b7153e674a1">&#9670;&nbsp;</a></span>Blink() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.Blink </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>containerPosition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refreshes all the stacks of a container in the rendering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">containerPosition</td><td>The ID of the container</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a844f1af60d72434237749cbe3e95b90b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844f1af60d72434237749cbe3e95b90b">&#9670;&nbsp;</a></span>Blink() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.Blink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refreshes all the stacks -in the inventory- in the rendering. </p>

</div>
</div>
<a id="a8ce42e8fdd21b7226d4c81a0d70e55be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce42e8fdd21b7226d4c81a0d70e55be">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears ALL THE INVENTORY. Deleting all the stacks from all the inventories. </p>

</div>
</div>
<a id="af6b09004328dd51890cd5d398c9c096c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b09004328dd51890cd5d398c9c096c">&#9670;&nbsp;</a></span>Export()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_serialized_inventory.html">Types.Inventory.SerializedInventory</a> WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.Export </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counterpart of Import(Types.Inventory.SerializedInventory), this method serializes the content of the inventory. </p>
<dl class="section return"><dt>Returns</dt><dd>The serialized content</dd></dl>

</div>
</div>
<a id="a43ee625958955530ac6ad437c7b75c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ee625958955530ac6ad437c7b75c58">&#9670;&nbsp;</a></span>Find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a> WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.Find </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>containerPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>stackPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a stack located in a particular container and a particular position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">containerPosition</td><td>The ID of the spatial container</td></tr>
    <tr><td class="paramname">stackPosition</td><td>The in-container position to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A stack occupying that position</dd></dl>

</div>
</div>
<a id="a57b04dc1649293e405585651710941b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b04dc1649293e405585651710941b3">&#9670;&nbsp;</a></span>FindAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IEnumerable&lt;<a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a>&gt; WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.FindAll </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>containerPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; <a class="el" href="class_support_1_1_types_1_1_tuple.html">Tuple</a>&lt; object, <a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a> &gt;, bool &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all the stacks in a particular container that satisfy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">containerPosition</td><td>The ID of the spatial container</td></tr>
    <tr><td class="paramname">predicate</td><td>The predicate they must satisfy</td></tr>
    <tr><td class="paramname">reverse</td><td>Whether the items should be traversed in reverse or straight way</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterable of stacks satisfying the predicate</dd></dl>

</div>
</div>
<a id="a06f494a3148710ad6039b3c9a2b715d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f494a3148710ad6039b3c9a2b715d5">&#9670;&nbsp;</a></span>FindAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IEnumerable&lt;<a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a>&gt; WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.FindAll </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>containerPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_wind_rose_1_1_scriptable_objects_1_1_inventory_1_1_items_1_1_item.html">ScriptableObjects.Inventory.Items.Item</a>&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all the stacks in a particular container of a particular item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">containerPosition</td><td>The ID of the spatial container</td></tr>
    <tr><td class="paramname">item</td><td>The item they have to be of</td></tr>
    <tr><td class="paramname">reverse</td><td>Whether the items should be traversed in reverse or straight way</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterable of stacks being of that item</dd></dl>

</div>
</div>
<a id="af7711676e9d84138f0967ea5550e8d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7711676e9d84138f0967ea5550e8d02">&#9670;&nbsp;</a></span>FindOne() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a> WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.FindOne </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>containerPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; <a class="el" href="class_support_1_1_types_1_1_tuple.html">Tuple</a>&lt; object, <a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a> &gt;, bool &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#a57b04dc1649293e405585651710941b3" title="Finds all the stacks in a particular container that satisfy a condition.">FindAll(object, Func&lt;Tuple&lt;object, Stack&gt;, bool&gt;, bool)</a> but only returns the first matched stack, or null. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">containerPosition</td><td>The ID of the spatial container</td></tr>
    <tr><td class="paramname">predicate</td><td>The predicate they must satisfy</td></tr>
    <tr><td class="paramname">reverse</td><td>Whether the items should be traversed in reverse or straight way</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first stack matched</dd></dl>

</div>
</div>
<a id="afacb29c3a7dd9bc7024eb622b9560a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afacb29c3a7dd9bc7024eb622b9560a4c">&#9670;&nbsp;</a></span>FindOne() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a> WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.FindOne </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>containerPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_wind_rose_1_1_scriptable_objects_1_1_inventory_1_1_items_1_1_item.html">ScriptableObjects.Inventory.Items.Item</a>&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like FindAll(object, ScriptableObjects.Inventory.Items.Item, bool) but only returns the first matched stack, or null. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">containerPosition</td><td>The ID of the spatial container</td></tr>
    <tr><td class="paramname">predicate</td><td>The predicate they must satisfy</td></tr>
    <tr><td class="paramname">reverse</td><td>Whether the items should be traversed in reverse or straight way</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first stack matched</dd></dl>

</div>
</div>
<a id="a752de5bfacc33b5d99b6acffe3675e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752de5bfacc33b5d99b6acffe3675e92">&#9670;&nbsp;</a></span>First()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a> WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.First </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>containerPosition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first item inside the given container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">containerPosition</td><td>The ID of the spatial container</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first item inside that container</dd></dl>

</div>
</div>
<a id="a5533bc1fb8576a40db91846df0d88974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5533bc1fb8576a40db91846df0d88974">&#9670;&nbsp;</a></span>Import()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.Import </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_serialized_inventory.html">Types.Inventory.SerializedInventory</a>&#160;</td>
          <td class="paramname"><em>serializedInventory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imports some serialized data and replaces the current content of the inventory manager with the parsed content from the serialized data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serializedInventory</td><td>The data to import for this inventory</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81e23171c45af7eab487e9314240627e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e23171c45af7eab487e9314240627e">&#9670;&nbsp;</a></span>Last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a> WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.Last </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>containerPosition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last item inside the given container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">containerPosition</td><td>The ID of the spatial container</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last item inside that container</dd></dl>

</div>
</div>
<a id="a7a86d05299db20c6a0a2c507e7a03b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a86d05299db20c6a0a2c507e7a03b7a">&#9670;&nbsp;</a></span>Merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.Merge </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>containerPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>destinationStackPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>sourceStackPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two stacks in the same containers, provided both stacks are "mergeable" between them. The source stack will be merged into the destination stack, and both stacks will be merged creating a new stack with added quantities and interpolated properties. For this to work, stacks must have usage strategies that CAN be interpolated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">containerPosition</td><td>The ID of the spatial container</td></tr>
    <tr><td class="paramname">destinationStackPosition</td><td>The destination stack position</td></tr>
    <tr><td class="paramname">sourceStackPosition</td><td>The source stack position</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether both source and destination stacks were found, quantities could be added, and they were compatible enough to succeed in the final step of merge/interpolation. </dd></dl>
<p>If quantities are saturated, there will be a partial merge and part of the source stack will still exist. Otherwise, the merge will be total and the source stack will be deleted. </p>

</div>
</div>
<a id="adce6916ddf53fe5297846e974c70578c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce6916ddf53fe5297846e974c70578c">&#9670;&nbsp;</a></span>Merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.Merge </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>destinationContainerPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>destinationStackPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html">InventoryManagementStrategyHolder</a>&#160;</td>
          <td class="paramname"><em>sourceHolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>sourceContainerPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>sourceStackPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="class_wind_rose_1_1_behaviours_1_1_inventory_1_1_inventory_management_strategy_holder.html#a7a86d05299db20c6a0a2c507e7a03b7a" title="Merges two stacks in the same containers, provided both stacks are &quot;mergeable&quot; between them....">Merge(object, object, object)</a>. This is an alternate version (actually: this is the generic one) which can merge across different inventories. The logic will remain the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destinationContainerPosition</td><td>The ID of the destination spatial container</td></tr>
    <tr><td class="paramname">destinationStackPosition</td><td>The position of the destination stack</td></tr>
    <tr><td class="paramname">sourceHolder</td><td>The source inventory managemnt strategy holder (our current instance is the destination one)</td></tr>
    <tr><td class="paramname">sourceContainerPosition</td><td>The ID of the source spatial container</td></tr>
    <tr><td class="paramname">sourceStackPosition</td><td>The position of the source stack</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether both source and destination stacks were found, quantities could be added, and they were compatible enough to succeed in the final step of merge/interpolation. </dd></dl>
<p>If quantities are saturated, there will be a partial merge and part of the source stack will still exist. Otherwise, the merge will be total and the source stack will be deleted. </p>

</div>
</div>
<a id="afe389b82c60b4a722ea9e5fed42aca47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe389b82c60b4a722ea9e5fed42aca47">&#9670;&nbsp;</a></span>Put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.Put </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>containerPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>stackPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a>&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out object&#160;</td>
          <td class="paramname"><em>finalStackPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool?&#160;</td>
          <td class="paramname"><em>optimalPutOnNullPosition</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts a stack (that must not belong to any inventory) in a specified container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">containerPosition</td><td>The ID of the spatial container</td></tr>
    <tr><td class="paramname">stackPosition</td><td>The in-container position to use - it may be null to let the inventory choose one instead</td></tr>
    <tr><td class="paramname">stack</td><td>The stack to add</td></tr>
    <tr><td class="paramname">finalStackPosition</td><td>The returned final position of the stack - if null, this means the stack was optimally distributed among existing "equal" stacks</td></tr>
    <tr><td class="paramname">optimalPutOnNullPosition</td><td>Whether an optimal put should be used on null stack position. options are:<ul>
<li>
<code>true</code> On null input position, this stack will not be added at first but instead tried to distribute among existing "equal" stacks.  </li>
<li>
<code>false</code>  On null input position, this stack will be added at the first-free available position (valid for the spatial strategies to be considered).   </li>
<li>
<code>null</code>  Makes the value of this parameter be set from optimalPutOnNullPosition property, whose meaning will be the same as the previous non-null options.   </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the stack could be put in the inventory's container (i.e. available position was appropriately got)</dd></dl>

</div>
</div>
<a id="aa14a78f409521eccbe4688d6f73c0d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14a78f409521eccbe4688d6f73c0d00">&#9670;&nbsp;</a></span>Remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.Remove </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>containerPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>stackPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the stack at certain position inside a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">containerPosition</td><td>The ID of the spatial container</td></tr>
    <tr><td class="paramname">stackPosition</td><td>The stack position to pop out of the inventory, if present</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether an element was found and removed at that position</dd></dl>

</div>
</div>
<a id="af4299112205847709bb888e012210d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4299112205847709bb888e012210d00">&#9670;&nbsp;</a></span>Split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.Split </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>sourceContainerPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>sourceStackPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>newStackContainerPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>newStackPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out object&#160;</td>
          <td class="paramname"><em>finalNewStackPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a stack in two, by taking a particular quantity of the source stack and creating a new one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceContainerPosition</td><td>The ID of the source spatial container</td></tr>
    <tr><td class="paramname">sourceStackPosition</td><td>The position of the source stack</td></tr>
    <tr><td class="paramname">quantity</td><td>The quantity to take from the source stack</td></tr>
    <tr><td class="paramname">newStackContainerPosition</td><td>The ID of the destination spatial container</td></tr>
    <tr><td class="paramname">newStackPosition</td><td>The position of the destination stack</td></tr>
    <tr><td class="paramname">finalNewStackPosition</td><td>Output parameter returning the final position given for the new stack</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the split could be performed (stack was found, quantity was available, and destination was free)</dd></dl>

</div>
</div>
<a id="ae0b12e5cd15c7ea2095a64dc1abfce99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b12e5cd15c7ea2095a64dc1abfce99">&#9670;&nbsp;</a></span>StackPairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IEnumerable&lt;<a class="el" href="class_support_1_1_types_1_1_tuple.html">Tuple</a>&lt;object, <a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a>&gt; &gt; WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.StackPairs </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>containerPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a particular container ID, this method returns an iterable traversing all the stacks in such container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">containerPosition</td><td>The ID of the spatial container</td></tr>
    <tr><td class="paramname">reverse</td><td>Whether the items should be traversed in reverse or straight way</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterable of pairs (in-container position, stack)</dd></dl>

</div>
</div>
<a id="ab05af5c5341f280be26eb5805edbcb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05af5c5341f280be26eb5805edbcb92">&#9670;&nbsp;</a></span>Take()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_wind_rose_1_1_types_1_1_inventory_1_1_stacks_1_1_stack.html">Stack</a> WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.Take </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>containerPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>stackPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disallowEmpty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes part of the specified stack. Just a quantity, and not necessarily the whole stack. If this method fails, it returns null (failure may occur by having a bigger quantity than what may be taken, or by the element not existing). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">containerPosition</td><td>The ID of the spatial container</td></tr>
    <tr><td class="paramname">stackPosition</td><td>The source stack position</td></tr>
    <tr><td class="paramname">quantity</td><td>The quantity to take</td></tr>
    <tr><td class="paramname">disallowEmpty</td><td>Whether we disallow the case of taking ALL the quantity, or we allow it</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A stack with the same specs, except for the quantity, or null if such quantity could not be taken</dd></dl>

</div>
</div>
<a id="a10ba41aaa0bf5841424585f516d31d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ba41aaa0bf5841424585f516d31d1a">&#9670;&nbsp;</a></span>Use() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.Use </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>containerPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>stackPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USES a stack in certain container and position. Using the item is an interaction between the usage strategy in the item/stack, and the usage strategy in the inventory (which is the one that has logic). The argument given to the use callback will be <code>null</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">containerPosition</td><td>The ID of the spatial container</td></tr>
    <tr><td class="paramname">stackPosition</td><td>The position of the stack being used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the usage interaction could be run</dd></dl>

</div>
</div>
<a id="ac059f9b93b2f6584ecd641e7aae940b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac059f9b93b2f6584ecd641e7aae940b6">&#9670;&nbsp;</a></span>Use() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool WindRose.Behaviours.Inventory.InventoryManagementStrategyHolder.Use </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>containerPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>sourceStackPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>argument</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USES a stack in certain container and position. Using the item is an interaction between the usage strategy in the item/stack, and the usage strategy in the inventory (which is the one that has logic). The argument given to the use callback will be also given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">containerPosition</td><td>The ID of the spatial container</td></tr>
    <tr><td class="paramname">stackPosition</td><td>The position of the stack being used</td></tr>
    <tr><td class="paramname">argument</td><td>The argument for the usage command</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the usage interaction could be run</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Assets/Scripts/WindRose/Behaviours/Inventory/InventoryManagementStrategyHolder.cs</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
